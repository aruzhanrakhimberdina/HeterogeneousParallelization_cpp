#include <iostream>   // Подключаем библиотеку для ввода и вывода данных (cout, endl)
#include <cstdlib>    // Подключаем библиотеку для работы с rand() и srand()
#include <ctime>      // Подключаем библиотеку для получения текущего времени (time)
#include <chrono>     // Подключаем библиотеку для точного измерения времени выполнения

using namespace std;  // Чтобы не писать std:: перед именами стандартных объектов

int main() {          // Главная функция программы — точка входа

    // Задание размера массива
    // Массив состоит из 1 000 000 целых чисел
    const int N = 1'000'000;   // Объявляем константу N — размер массива

    // Динамическое выделение памяти под массив
    // Память выделяется во время выполнения программы
    // с использованием оператора new[]
    int* arr = new int[N];     // Выделяем в динамической памяти массив из N элементов типа int

    // Инициализация генератора псевдослучайных чисел
    // В качестве начального значения используется текущее время
    srand(static_cast<unsigned>(time(nullptr)));  // Инициализируем генератор случайных чисел текущим временем

    // Заполнение массива случайными целыми значениями
    for (int i = 0; i < N; ++i) {   // Цикл от 0 до N-1 для заполнения массива
        arr[i] = rand();            // Присваиваем каждому элементу массива случайное число
    }

    // Последовательный алгоритм поиска минимального
    // и максимального элементов массива

    // Начальный момент времени перед выполнением алгоритма
    auto start = chrono::high_resolution_clock::now();  // Запоминаем текущее время как начало измерения

    int minVal = arr[0];   // Инициализируем минимальное значение первым элементом массива
    int maxVal = arr[0];   // Инициализируем максимальное значение первым элементом массива

    // Последовательный просмотр всех элементов массива
    // с обновлением текущих значений минимума и максимума
    for (int i = 1; i < N; ++i) {   // Цикл перебора массива начиная со второго элемента
        if (arr[i] < minVal) {      // Если текущий элемент меньше текущего минимума
            minVal = arr[i];        // Обновляем минимальное значение
        }
        if (arr[i] > maxVal) {      // Если текущий элемент больше текущего максимума
            maxVal = arr[i];        // Обновляем максимальное значение
        }
    }

    // Конечный момент времени после выполнения алгоритма
    auto end = chrono::high_resolution_clock::now();  // Фиксируем текущее время как конец измерения

    // Вычисление времени выполнения алгоритма
    chrono::duration<double, milli> duration = end - start;  // Вычисляем разницу между концом и началом в миллисекундах

    // Вывод результатов вычислений и времени выполнения
    cout << "Minimum value: " << minVal << endl;        // Выводим минимальное значение массива
    cout << "Maximum value: " << maxVal << endl;        // Выводим максимальное значение массива
    cout << "Execution time: " << duration.count() << " ms" << endl;  // Выводим время выполнения алгоритма

    // Освобождение динамически выделенной памяти
    // Предотвращает утечку памяти после завершения программы
    delete[] arr;    // Освобождаем память, выделенную под массив

    return 0;        // Завершаем программу с кодом успешного выполнения
}
