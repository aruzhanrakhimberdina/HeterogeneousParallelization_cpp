#include <iostream>   // Подключаем библиотеку для ввода/вывода (cout, endl)
#include <cstdlib>    // Подключаем библиотеку для rand(), srand()
#include <ctime>      // Подключаем библиотеку для time()
#include <chrono>     // Подключаем библиотеку для измерения времени выполнения

#ifdef _OPENMP        // Если компилятор собран с поддержкой OpenMP (макрос _OPENMP определён)
#include <omp.h>      // Подключаем библиотеку OpenMP (omp_get_max_threads и т.д.)
#endif                // Закрываем условную компиляцию для OpenMP

using namespace std;  // Чтобы не писать std:: перед стандартными объектами/функциями

int main() {          // Главная функция — старт выполнения программы

    // Установка локали для русского языка (для корректного вывода кириллицы)
    setlocale(LC_ALL, "Russian");   // Устанавливаем локаль для всей программы

    // Задание размера массива
    // Массив содержит 1 000 000 целых чисел
    const int N = 1'000'000;        // Размер массива N = 1 000 000 (разделитель ' для читабельности)

    // Динамическое выделение памяти под массив
    int* arr = new int[N];          // Выделяем в динамической памяти массив из N целых чисел

    // Инициализация генератора псевдослучайных чисел
    srand(static_cast<unsigned>(time(nullptr))); // Запускаем rand() с "зерном" от текущего времени

    // Заполнение массива случайными значениями
    for (int i = 0; i < N; ++i) {   // Проходим по всем индексам массива
        arr[i] = rand();            // Записываем в arr[i] случайное целое число
    }                               // Конец цикла заполнения

    // 1) Последовательный поиск минимума и максимума

    auto start_seq = chrono::high_resolution_clock::now(); // Запоминаем старт времени (seq)

    int min_seq = arr[0];           // Начальный минимум — первый элемент массива
    int max_seq = arr[0];           // Начальный максимум — первый элемент массива

    for (int i = 1; i < N; ++i) {   // Перебираем элементы массива начиная со второго
        if (arr[i] < min_seq) min_seq = arr[i]; // Если нашли меньше — обновляем минимум
        if (arr[i] > max_seq) max_seq = arr[i]; // Если нашли больше — обновляем максимум
    }                               // Конец последовательного поиска

    auto end_seq = chrono::high_resolution_clock::now();   // Запоминаем конец времени (seq)
    chrono::duration<double, milli> dur_seq = end_seq - start_seq; // Считаем длительность в миллисекундах
    
    // 2) Параллельный поиск минимума и максимума (OpenMP)

    int min_par = arr[0];           // Общий минимум для параллельной версии (стартуем с arr[0])
    int max_par = arr[0];           // Общий максимум для параллельной версии (стартуем с arr[0])

    auto start_par = chrono::high_resolution_clock::now(); // Запоминаем старт времени (par)

#ifdef _OPENMP        // Если OpenMP доступен — выполняем параллельную версию
#pragma omp parallel  // Создаём параллельную область: код внутри выполняется несколькими потоками
    {                 // Начало параллельного блока
        int local_min = arr[0];     // Локальный минимум для каждого потока
        int local_max = arr[0];     // Локальный максимум для каждого потока

#pragma omp for        // Делим цикл for по потокам (каждый поток получает свой кусок итераций)
        for (int i = 1; i < N; ++i) {         // Каждый поток проходит свою часть массива
            if (arr[i] < local_min) local_min = arr[i]; // Обновляем локальный минимум потока
            if (arr[i] > local_max) local_max = arr[i]; // Обновляем локальный максимум потока
        }                                      // Конец параллельного цикла

#pragma omp critical   // Критическая секция: сюда потоки заходят по одному (без гонок данных)
        {              // Начало критической секции
            if (local_min < min_par) min_par = local_min; // Обновляем общий минимум
            if (local_max > max_par) max_par = local_max; // Обновляем общий максимум
        }              // Конец критической секции
    }                  // Конец параллельного блока
#else                  // Если OpenMP не поддерживается — делаем обычный последовательный код
    for (int i = 1; i < N; ++i) {   // Перебираем элементы массива
        if (arr[i] < min_par) min_par = arr[i]; // Обновляем минимум
        if (arr[i] > max_par) max_par = arr[i]; // Обновляем максимум
    }                               // Конец запасного последовательного блока
#endif                 // Конец условной компиляции OpenMP

    auto end_par = chrono::high_resolution_clock::now();   // Запоминаем конец времени (par)
    chrono::duration<double, milli> dur_par = end_par - start_par; // Считаем длительность в миллисекундах

    // 3) Сравниваем результаты

    cout << "Последовательно: min = " << min_seq            // Печатаем минимум последовательной версии
        << ", max = " << max_seq                            // Печатаем максимум последовательной версии
        << ", время = " << dur_seq.count() << " мс\n";      // Печатаем время последовательной версии

    cout << "Параллельно:     min = " << min_par            // Печатаем минимум параллельной версии
        << ", max = " << max_par                            // Печатаем максимум параллельной версии
        << ", время = " << dur_par.count() << " мс\n";      // Печатаем время параллельной версии

    // Проверка корректности параллельного алгоритма:
    // сравниваем результаты последовательной и параллельной версий
    if (min_seq != min_par || max_seq != max_par) {         // Если хоть один результат не совпал
        cout << "Результаты отличаются!\n";                 // Сообщаем, что есть ошибка/расхождение
    }
    else {                                                  // Иначе (всё совпало)
        cout << "Результаты совпадают. Параллельный алгоритм работает корректно.\n"; // Сообщаем успех
    }

    // Вычисление ускорения и эффективности
    if (dur_par.count() > 0.0) {                            // Проверяем, что время параллельной версии не ноль
        double speedup = dur_seq.count() / dur_par.count(); // Ускорение = время seq / время par
        cout << "Ускорение (speedup): " << speedup << "x\n"; // Печатаем ускорение

#ifdef _OPENMP
        int threads = omp_get_max_threads();                // Получаем максимальное число потоков OpenMP
        cout << "Максимальное количество потоков OpenMP: " << threads << endl; // Печатаем число потоков
        cout << "Эффективность: " << (speedup / threads * 100.0) << "%\n";     // Эффективность в %
#else
        cout << "OpenMP не доступен (программа собрана без поддержки OpenMP)\n"; // Сообщение если нет OpenMP
#endif
    }                                                       // Конец блока ускорения/эффективности

    // Освобождение динамически выделенной памяти
    delete[] arr;                                           // Освобождаем память, чтобы не было утечки

    return 0;                                               // Завершаем программу успешно
}                                                           // Конец main()
