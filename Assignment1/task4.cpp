#include <iostream>   // Подключаем библиотеку для ввода и вывода (cout, endl)
#include <cstdlib>    // Подключаем библиотеку для rand() и srand()
#include <ctime>      // Подключаем библиотеку для работы со временем (time)
#include <chrono>     // Подключаем библиотеку для измерения времени выполнения

#ifdef _OPENMP        // Проверяем, определён ли макрос _OPENMP (поддержка OpenMP)
#include <omp.h>      // Подключаем заголовок OpenMP
#endif                // Конец условного подключения OpenMP

using namespace std;  // Чтобы не писать std:: перед стандартными именами

int main() {          // Главная функция программы — точка входа

    // Установка локали для русского языка
    setlocale(LC_ALL, "Russian");   // Устанавливаем локаль для корректного вывода кириллицы

    // Задание размера массива
    // Массив содержит 5 000 000 целых чисел

    const int N = 5'000'000;        // Объявляем константу N — размер массива

    // Динамическое выделение памяти под массив
    // Память выделяется во время выполнения программы
    int* arr = new int[N];          // Выделяем в динамической памяти массив из N элементов типа int

    // Инициализация генератора псевдослучайных чисел
    srand(static_cast<unsigned>(time(nullptr))); // Инициализируем rand() текущим временем

    // Заполнение массива случайными целыми числами в диапазоне [1; 100]
    for (int i = 0; i < N; ++i) {   // Цикл по всем элементам массива
        arr[i] = rand() % 100 + 1;  // Генерируем случайное число от 1 до 100 и записываем его в массив
    }                               // Конец цикла заполнения массива

    // 1) Последовательное вычисление среднего

    // Фиксация начального момента времени
    // перед выполнением последовательного алгоритма
    auto start_seq = chrono::high_resolution_clock::now(); // Запоминаем текущее время (начало seq)

    // Последовательный подсчёт суммы элементов массива
    long long sum_seq = 0;          // Объявляем переменную для хранения суммы элементов массива
    for (int i = 0; i < N; ++i) {   // Перебираем все элементы массива
        sum_seq += arr[i];          // Прибавляем каждый элемент к общей сумме
    }                               // Конец последовательного подсчёта суммы

    // Вычисление среднего значения
    // Приведение к типу double необходимо для корректного
    // получения дробного результата
    double avg_seq = static_cast<double>(sum_seq) / N; // Вычисляем среднее значение

    // Фиксация конечного момента времени и вычисление длительности
    auto end_seq = chrono::high_resolution_clock::now();  // Фиксируем конец времени (seq)
    chrono::duration<double, milli> dur_seq = end_seq - start_seq; // Считаем длительность в мс

    // 2) Параллельное вычисление среднего

    // Фиксация начального момента времени
    // перед выполнением параллельного алгоритма
    auto start_par = chrono::high_resolution_clock::now(); // Запоминаем текущее время (начало par)

    // Переменная для суммирования в параллельной области
    // Используется тип long long для предотвращения переполнения
    long long sum_par = 0;          // Переменная для хранения суммы (параллельная версия)

#ifdef _OPENMP
    // Параллельная обработка массива:
    // директива reduction(+:sum_par) создаёт локальные частичные суммы
    // для каждого потока и корректно объединяет их по завершении цикла
#pragma omp parallel for reduction(+: sum_par) // Запускаем параллельный цикл с редукцией по сумме
    for (int i = 0; i < N; ++i) {   // Каждый поток обрабатывает часть массива
        sum_par += arr[i];          // Добавляем элемент массива к локальной сумме потока
    }                               // После цикла все локальные суммы объединяются в sum_par
#else
    // Если поддержка OpenMP отсутствует, выполняем вычисления
    // последовательно (аналог параллельного блока)
    for (int i = 0; i < N; ++i) {   // Последовательный цикл по массиву
        sum_par += arr[i];          // Прибавляем каждый элемент к общей сумме
    }                               // Конец запасного последовательного блока
#endif

    // Вычисление среднего значения по сумме, полученной параллельно
    double avg_par = static_cast<double>(sum_par) / N; // Вычисляем среднее значение (par)

    // Фиксация конечного момента времени и вычисление длительности
    auto end_par = chrono::high_resolution_clock::now();  // Фиксируем конец времени (par)
    chrono::duration<double, milli> dur_par = end_par - start_par; // Считаем длительность в мс

    // 3) Сравнение результатов

    cout << "Последовательно: average = " << avg_seq       // Вывод среднего значения (seq)
        << ", время = " << dur_seq.count() << " мс\n";     // Вывод времени выполнения (seq)

    cout << "Параллельно:     average = " << avg_par       // Вывод среднего значения (par)
        << ", время = " << dur_par.count() << " мс\n";     // Вывод времени выполнения (par)

    // Проверка корректности параллельного алгоритма:
    // сравниваются средние значения, полученные последовательным
    // и параллельным способом

    double diff = avg_seq - avg_par; // Вычисляем разницу между результатами
    if (diff < 0) diff = -diff;      // Берём модуль разницы

    if (diff > 1e-9) {               // Если разница больше допустимой погрешности
        cout << "Средние значения отличаются!\n"; // Сообщаем об ошибке
    }
    else {                           // Иначе (результаты совпадают)
        cout << "Результаты совпадают. Параллельный алгоритм работает корректно.\n"; // Всё ок
    }

    // Вычисление ускорения и эффективности параллельного алгоритма
    if (dur_par.count() > 0.0) {     // Проверяем, что время параллельной версии больше нуля
        double speedup = dur_seq.count() / dur_par.count(); // Ускорение = seq / par
        cout << "Ускорение (speedup): " << speedup << "x\n"; // Вывод ускорения

#ifdef _OPENMP
        int threads = omp_get_max_threads(); // Получаем максимальное число потоков OpenMP
        cout << "Максимальное количество потоков OpenMP: " << threads << endl; // Вывод потоков
        cout << "Эффективность: " << (speedup / threads * 100.0) << "%\n";     // Вывод эффективности
#else
        cout << "OpenMP не доступен (программа собрана без поддержки OpenMP)\n"; // Сообщение если нет OpenMP
#endif
    }

    // Освобождение динамически выделенной памяти
    delete[] arr;                    // Освобождаем память, чтобы не было утечки

    return 0;                        // Завершаем программу успешно
}                                    // Конец функции main
