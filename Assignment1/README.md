# Assignment 1 - Основы C/C++ и OpenMP

## Описание
Данный репозиторий содержит решения заданий 1-4 для Assignment 1 

## Структура проекта

- `task1.cpp`  
  Динамическое выделение массива из 50 000 целых чисел, заполнение случайными
  значениями в диапазоне [1; 100], вычисление среднего значения элементов массива
  и корректное освобождение памяти.

- `task2.cpp`  
  Создание массива из 1 000 000 целых чисел и реализация последовательного
  алгоритма поиска минимального и максимального элементов с замером времени выполнения.

- `task3.cpp`  
  Последовательный и параллельный (OpenMP) поиск минимального и максимального
  элементов массива из 1 000 000 чисел, сравнение времени выполнения и проверка
  корректности параллельного алгоритма.

- `task4.cpp`  
  Последовательное и параллельное (OpenMP с использованием reduction) вычисление
  среднего значения элементов массива из 5 000 000 чисел, сравнение времени
  выполнения и анализ ускорения.

---


## Контрольные вопросы к Assignment 1  
*(Основы C/C++ и OpenMP)*

### 1. В чём отличие динамического массива от статического массива в C++?
Статический массив имеет фиксированный размер, который задаётся во время компиляции и не может быть изменён в процессе выполнения программы.  
Динамический массив создаётся во время выполнения программы, при этом его размер может задаваться и изменяться динамически.

---

### 2. Что такое указатель и зачем он используется при работе с динамической памятью?
Указатель - это переменная, которая хранит адрес области памяти.  
При работе с динамической памятью указатель используется для доступа к выделенному участку памяти, а также для его последующего освобождения.

---

### 3. Почему важно корректно освобождать память после использования динамических массивов?
Если динамически выделенная память не освобождается, возникает утечка памяти.  
Это приводит к увеличению потребления оперативной памяти программой и может вызвать снижение производительности или аварийное завершение программы.

---

### 4. В чём разница между последовательной и параллельной обработкой массива?
При последовательной обработке все элементы массива обрабатываются одним потоком по очереди.  
При параллельной обработке массив разбивается на части, и разные потоки обрабатывают эти части одновременно, что может привести к ускорению выполнения программы.

---

### 5. Что делает директива `#pragma omp parallel for`?
Директива `#pragma omp parallel for` автоматически распределяет итерации цикла `for` между несколькими потоками, позволяя выполнять цикл параллельно.

---

### 6. Для чего используется механизм `reduction` в OpenMP?
Механизм `reduction` используется для корректного объединения результатов, вычисленных в разных потоках, в одно итоговое значение (например, сумму, минимум или максимум).

---

### 7. Почему при параллельном вычислении суммы необходимо использовать `reduction`, а не обычную переменную?
При использовании обычной переменной несколько потоков могут одновременно изменять её значение, что приводит к состоянию гонки и неверному результату.  
Механизм `reduction` создаёт локальные копии переменной для каждого потока и безопасно объединяет их в конце вычислений.

---

### 8. Какие факторы могут привести к тому, что параллельная версия программы будет работать медленнее последовательной?
Параллельная версия программы может работать медленнее из-за следующих факторов:
- небольшое количество обрабатываемых данных;
- накладные расходы на создание и управление потоками;
- частая синхронизация между потоками;
- использование мьютексов или блокировок;
- неэффективное распределение работы между потоками.
