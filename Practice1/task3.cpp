#include <iostream>   // Подключаем библиотеку для ввода и вывода (cout, cin)
#include <cstdlib>    // Подключаем библиотеку для работы с rand() и srand()
#include <ctime>      // Подключаем библиотеку для получения текущего времени (time)
#include <chrono>     // Подключаем библиотеку для измерения времени выполнения
#include <omp.h>      // Подключаем библиотеку OpenMP для параллельных вычислений

using namespace std;  // Чтобы не писать std:: перед стандартными именами

// Функция заполнения массива случайными числами
// arr — указатель на массив
// n — размер массива
// maxValue — максимальное значение случайного числа (по умолчанию 100)
void fillRandom(int* arr, int n, int maxValue = 100) {
    for (int i = 0; i < n; ++i) {          // Цикл по всем элементам массива
        arr[i] = rand() % maxValue + 1;   // Записываем случайное число в диапазоне [1..maxValue]
    }                                      // Конец цикла заполнения
}

// Функция последовательного вычисления среднего значения массива
// arr — указатель на массив
// n — размер массива
// timeMs — ссылка на переменную, в которую будет записано время выполнения (мс)
double averageSequential(const int* arr, int n, double& timeMs) {
    long long sum = 0;                    // Переменная для хранения суммы элементов массива

    auto start = chrono::high_resolution_clock::now();  // Фиксируем начальный момент времени

    for (int i = 0; i < n; ++i) {         // Последовательно перебираем элементы массива
        sum += arr[i];                    // Добавляем текущий элемент к сумме
    }                                     // Конец последовательного цикла

    auto end = chrono::high_resolution_clock::now();    // Фиксируем конечный момент времени

    timeMs = chrono::duration<double, milli>(end - start).count();  // Вычисляем длительность в миллисекундах

    return static_cast<double>(sum) / n;  // Возвращаем среднее значение массива
}

// Функция параллельного вычисления среднего значения массива с использованием OpenMP
// Используется директива reduction для корректного суммирования значений из разных потоков
double averageParallelOMP(const int* arr, int n, double& timeMs) {
    long long sum = 0;                    // Общая переменная для суммы элементов массива

    auto start = chrono::high_resolution_clock::now();  // Фиксируем начальный момент времени

#pragma omp parallel for reduction(+:sum) // Параллельный цикл с редукцией по сумме
    for (int i = 0; i < n; ++i) {         // Каждый поток обрабатывает свою часть массива
        sum += arr[i];                    // Добавляем элемент к локальной сумме потока
    }                                     // После завершения цикла все локальные суммы объединяются в sum

    auto end = chrono::high_resolution_clock::now();    // Фиксируем конечный момент времени

    timeMs = chrono::duration<double, milli>(end - start).count();  // Вычисляем длительность в миллисекундах

    return static_cast<double>(sum) / n;  // Возвращаем среднее значение массива
}

int main() {                               // Главная функция программы
    setlocale(LC_ALL, "Russian");          // Устанавливаем локаль для корректного отображения кириллицы
    srand(static_cast<unsigned>(time(nullptr)));  // Инициализируем генератор случайных чисел текущим временем

    int n = 0;                             // Переменная для хранения размера массива
    cout << "Введите N (размер массива): "; // Запрашиваем у пользователя размер массива
    cin >> n;                              // Считываем значение N с клавиатуры

    if (n <= 0) {                          // Проверяем корректность введённого значения
        cout << "Ошибка: N должен быть больше 0.\n"; // Сообщаем об ошибке
        return 1;                          // Завершаем программу с кодом ошибки
    }

    // Динамическое выделение памяти под массив из n элементов
    int* arr = new int[n];                 // Выделяем память для массива

    // Заполняем массив случайными значениями
    fillRandom(arr, n, 100);               // Вызываем функцию заполнения массива

    // Последовательное вычисление среднего значения массива
    double seqTime = 0.0;                  // Переменная для хранения времени последовательного алгоритма
    double avgSeq = averageSequential(arr, n, seqTime); // Вычисляем среднее последовательно

    // Параллельное вычисление среднего значения массива
    double parTime = 0.0;                  // Переменная для хранения времени параллельного алгоритма
    double avgPar = averageParallelOMP(arr, n, parTime); // Вычисляем среднее параллельно

    // Вывод результатов вычислений
    cout << "\nРезультаты:\n";             // Заголовок блока результатов
    cout << "Последовательно: среднее = " << avgSeq << ", time = " << seqTime << " ms\n"; // Вывод seq-результата
    cout << "Параллельно:     среднее = " << avgPar << ", time = " << parTime << " ms\n"; // Вывод par-результата

    // Освобождение динамически выделенной памяти
    delete[] arr;                          // Освобождаем память, чтобы избежать утечки

    return 0;                              // Завершаем программу успешно
}
