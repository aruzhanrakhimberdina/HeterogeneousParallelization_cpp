#include <iostream>      // Подключаем библиотеку для работы с вводом и выводом (cout, endl)
#include <cstdlib>       // Подключаем библиотеку для функций rand() и srand()
#include <ctime>         // Подключаем библиотеку для получения текущего времени (time)
#include <chrono>        // Подключаем библиотеку для измерения времени выполнения

#ifdef _OPENMP           // Проверяем, определён ли макрос _OPENMP (поддержка OpenMP)
#include <omp.h>         // Подключаем заголовок OpenMP
#endif

using namespace std;     // Используем стандартное пространство имён

int main() {             // Главная функция программы

    setlocale(LC_ALL, "Russian");          // Устанавливаем локаль для корректного отображения кириллицы

    const int N = 10000;                   // Объявляем размер массива — 10 000 элементов
    int* arr = new int[N];                 // Динамически выделяем память под массив из N целых чисел

    srand(static_cast<unsigned>(time(nullptr))); // Инициализируем генератор случайных чисел текущим временем

    for (int i = 0; i < N; ++i) {          // Цикл для заполнения массива
        arr[i] = rand() % 100000 + 1;      // Записываем в массив случайное число от 1 до 100000
    }

    // Последовательно

    auto start_seq = chrono::high_resolution_clock::now(); // Фиксируем начальный момент времени

    int min_seq = arr[0];                  // Инициализируем минимум первым элементом массива
    int max_seq = arr[0];                  // Инициализируем максимум первым элементом массива

    for (int i = 1; i < N; ++i) {          // Последовательно перебираем элементы массива
        if (arr[i] < min_seq) min_seq = arr[i]; // Если текущий элемент меньше минимума — обновляем минимум
        if (arr[i] > max_seq) max_seq = arr[i]; // Если текущий элемент больше максимума — обновляем максимум
    }

    auto end_seq = chrono::high_resolution_clock::now();   // Фиксируем момент окончания измерения времени
    double time_seq = chrono::duration<double, milli>(end_seq - start_seq).count(); // Вычисляем время в миллисекундах

    // Параллельно

    auto start_par = chrono::high_resolution_clock::now(); // Фиксируем начальный момент времени для параллельной версии

    int min_par = arr[0];                  // Инициализируем минимум для параллельной версии
    int max_par = arr[0];                  // Инициализируем максимум для параллельной версии

#ifdef _OPENMP                           // Если поддержка OpenMP включена
#pragma omp parallel                     // Создаём параллельную область
    {
        int local_min = arr[0];           // Локальный минимум для каждого потока
        int local_max = arr[0];           // Локальный максимум для каждого потока

#pragma omp for                          // Делим цикл по потокам
        for (int i = 1; i < N; ++i) {    // Каждый поток обрабатывает свою часть массива
            if (arr[i] < local_min) local_min = arr[i]; // Обновляем локальный минимум
            if (arr[i] > local_max) local_max = arr[i]; // Обновляем локальный максимум
        }

#pragma omp critical                     // Критическая секция - защита общих переменных
        {
            if (local_min < min_par) min_par = local_min; // Обновляем общий минимум
            if (local_max > max_par) max_par = local_max; // Обновляем общий максимум
        }
    }
#else                                    // Если OpenMP не поддерживается
    for (int i = 1; i < N; ++i) {         // Используем обычный последовательный цикл
        if (arr[i] < min_par) min_par = arr[i];
        if (arr[i] > max_par) max_par = arr[i];
    }
#endif

    auto end_par = chrono::high_resolution_clock::now();   // Фиксируем момент окончания измерения времени
    double time_par = chrono::duration<double, milli>(end_par - start_par).count(); // Вычисляем время в миллисекундах

    // ---------------- Вывод результатов ----------------

    cout << "Последовательно: min = " << min_seq
        << ", max = " << max_seq
        << ", time = " << time_seq << " ms\n";           // Выводим результаты последовательной версии

    cout << "Параллельно:     min = " << min_par
        << ", max = " << max_par
        << ", time = " << time_par << " ms\n";           // Выводим результаты параллельной версии

    if (min_seq != min_par || max_seq != max_par) {       // Проверяем, совпадают ли результаты
        cout << "Результаты отличаются!\n";               // Сообщаем, если найдено расхождение
    }

    // Сравнение времени выполнения и формулировка вывода
    if (time_par < time_seq) {                             // Если параллельная версия быстрее
        cout << "Вывод: параллельная версия работает быстрее на данном размере массива.\n";
    }
    else if (time_par > time_seq) {                      // Если последовательная версия быстрее
        cout << "Вывод: последовательная версия оказалась быстрее из-за накладных расходов на параллелизацию.\n";
    }
    else {                                               // Если время примерно одинаковое
        cout << "Вывод: обе версии работают примерно за одинаковое время.\n";
    }

#ifdef _OPENMP
    cout << "Использовано потоков OpenMP: " << omp_get_max_threads() << "\n"; // Выводим число потоков
#endif

    delete[] arr;                         // Освобождаем динамически выделенную память

    return 0;                             // Завершаем программу успешно
}
