# Практическая работа 2
### Контрольные вопросы 

---

## 1. В чём основные отличия между массивами и динамическими структурами данных?

Массив - это структура данных с фиксированным размером, который задаётся при создании и потом не может изменяться. Все элементы массива хранятся подряд в памяти, поэтому к ним удобно и быстро обращаться по индексу.

Динамические структуры данных (например, связные списки, деревья) создаются в динамической памяти и могут менять свой размер во время работы программы - элементы можно добавлять и удалять по ходу выполнения. За счёт этого они более гибкие, но работают немного медленнее и требуют больше памяти.

---

## 2. Что такое указатель, и как он используется в языке C++?

Указатель - это специальная переменная, которая хранит адрес другой переменной в памяти. То есть он не хранит само значение, а показывает, где оно находится.

В C++ указатели используются для работы с динамической памятью (через `new` и `delete`), для передачи больших объектов в функции без копирования и для реализации динамических структур данных, таких как списки и деревья.

---

## 3. Объясните принцип работы стека и очереди

Стек - это структура данных, которая работает по принципу «последний пришёл - первый ушёл» (LIFO). Элемент добавляется на вершину стека и оттуда же удаляется.

Очередь работает по принципу «первый пришёл - первый ушёл» (FIFO). Элементы добавляются в конец очереди, а удаляются из начала.

---

## 4. Каковы преимущества и недостатки односвязных списков по сравнению с массивами?

Главное преимущество односвязного списка - это то, что в него легко добавлять и удалять элементы, не нужно сдвигать остальные данные, как в массиве. Также список может динамически расти и уменьшаться.

Недостатки заключаются в том, что нет быстрого доступа по индексу - чтобы дойти до нужного элемента, нужно пройти все предыдущие. Кроме того, каждый элемент хранит указатель, что увеличивает расход памяти.

---

## 5. Как правильно освобождать память в языке C++ после работы с динамическими структурами?

Память, выделенная с помощью `new`, должна освобождаться с помощью `delete`, а память, выделенная с помощью `new[]`, - с помощью `delete[]`.

Если не освобождать память, возникает утечка памяти, что может привести к замедлению работы программы и увеличению потребления ресурсов.

---

## 6. Почему важно понимать работу с указателями и динамической памятью для параллельного программирования?

В параллельных программах несколько потоков могут одновременно работать с одной и той же областью памяти. Без понимания указателей и структуры памяти легко допустить ситуацию гонки данных, когда потоки мешают друг другу.

Понимание этих механизмов позволяет писать корректные и безопасные параллельные программы.

---

## 7. Как использовать reduction в OpenMP для нахождения суммы, минимума или максимума?

В OpenMP директива `reduction` позволяет каждому потоку считать свою часть результата, а затем автоматически объединить все частичные результаты.

Примеры:
- `reduction(+:sum)` — для суммы  
- `reduction(min:minVal)` — для минимума  
- `reduction(max:maxVal)` — для максимума  

Это помогает избежать гонок данных и получить корректный результат.

---

## 8. Как влияет параллельное программирование на производительность при работе с большими массивами?

Параллельное программирование ускоряет обработку больших массивов за счёт распределения работы между несколькими ядрами процессора.

Однако при небольших объёмах данных или больших накладных расходах на управление потоками параллельная версия может работать медленнее последовательной.


