#include <iostream>      // Потоковый ввод/вывод: cout, cin, endl
#include <vector>        // std::vector — динамический массив с автоматическим управлением памятью
#include <random>        // Современная генерация случайных чисел (лучше, чем rand)
#include <chrono>        // Измерение времени: high_resolution_clock, duration
#include <omp.h>         // OpenMP: директивы #pragma omp ... и функции управления потоками

using namespace std;     // Используем имена из std без префикса std::
using namespace chrono;  // Используем типы/функции chrono без префикса chrono::


vector<int> generateArray(int n) {                   // Функция возвращает vector<int> длины n
    vector<int> a(n);                                // Создаём вектор из n элементов (память выделяется автоматически)

    random_device rd;                                // Источник для seed 
    mt19937 gen(rd());                               // Генератор инициализированный seed-значением
    uniform_int_distribution<> dist(0, 100000);      // Равномерно генерируем числа от 0 до 100000 включительно

    for (int i = 0; i < n; i++)                      // Проходим по всем индексам вектора
        a[i] = dist(gen);                            // Записываем в a[i] новое случайное число из распределения

    return a;                                        // Возвращаем готовый вектор (копирование обычно оптимизируется)
}

//ПОСЛЕДОВАТЕЛЬНЫЕ АЛГОРИТМЫ

/*
  bubbleSortSeq(a)
  Пузырьковая сортировка (последовательно)
  - Много раз проходим по массиву
  - Сравниваем соседние элементы и меняем местами, если они не по порядку
  - После i-го прохода самый большой элемент "всплывает" в конец
*/
void bubbleSortSeq(vector<int>& a) {                 // Сортируем вектор по ссылке (изменяем исходный массив)
    int n = a.size();                                // Берём размер массива
    for (int i = 0; i < n - 1; i++)                  // Количество проходов по массиву
        for (int j = 0; j < n - 1 - i; j++)          // Сравниваем пары (j, j+1), уменьшая диапазон (хвост уже отсортирован)
            if (a[j] > a[j + 1])                     // Если соседи стоят в неправильном порядке
                swap(a[j], a[j + 1]);                // Меняем местами
}

/*
  selectionSortSeq(a)
  Сортировка выбором (последовательно)
  - На позиции i ищем минимальный элемент среди [i..n-1]
  - Меняем местами a[i] и найденный минимум
  - Так фиксируем "правильный" элемент слева
*/
void selectionSortSeq(vector<int>& a) {
    int n = a.size();                                // Размер массива
    for (int i = 0; i < n - 1; i++) {                // Позиция, куда ставим очередной минимум
        int minIdx = i;                              // Предполагаем, что минимум - текущий i
        for (int j = i + 1; j < n; j++)              // Ищем настоящий минимум справа
            if (a[j] < a[minIdx])                    // Нашли элемент меньше текущего минимума
                minIdx = j;                          // Запоминаем его индекс
        swap(a[i], a[minIdx]);                       // Ставим минимум на позицию i
    }
}

/*
  insertionSortSeq(a)
  Сортировка вставками (последовательно)
  - Слева держим уже отсортированную часть
  - Берём текущий элемент key и "вставляем" его в нужное место слева,
    сдвигая более крупные элементы вправо
*/
void insertionSortSeq(vector<int>& a) {
    int n = a.size();                                // Размер массива
    for (int i = 1; i < n; i++) {                    // Начинаем со второго элемента (первый уже "отсортирован")
        int key = a[i];                              // Элемент, который вставляем в отсортированную часть слева
        int j = i - 1;                               // Индекс элемента слева от key
        while (j >= 0 && a[j] > key) {               // Пока слева элементы больше key
            a[j + 1] = a[j];                         // Сдвигаем элемент вправо
            j--;                                     // Двигаемся левее
        }
        a[j + 1] = key;                              // Ставим key в найденную позицию
    }
}

// ПАРАЛЛЕЛЬНЫЕ АЛГОРИТМЫ (OpenMP) 

/*
  bubbleSortPar(a)
  Попытка параллелизации пузырька.
  Как устроено:
  - Внешний цикл делает проходы.
  - Внутренний цикл распараллелен: разные потоки одновременно сравнивают разные пары.

*/
void bubbleSortPar(vector<int>& a) {
    int n = a.size();                                // Размер массива
    for (int i = 0; i < n; i++) {                    // Количество проходов
#pragma omp parallel for                              // Делим итерации внутреннего цикла по потокам
        for (int j = 0; j < n - 1; j++) {            // Сравнение соседних элементов по всему массиву
            if (a[j] > a[j + 1])                     // Если соседние элементы не по порядку
                swap(a[j], a[j + 1]);                // Меняем их местами
        }
    }
}

/*
  selectionSortPar(a)
  - На каждом шаге i нужно найти минимум на отрезке [i..n-1]
  - Поиск минимума можно распараллелить: разные потоки смотрят разные j

  Что делает critical:
  - minIdx общий, и его обновление нужно защищать,
    иначе потоки одновременно поменяют minIdx и всё сломается.
*/
void selectionSortPar(vector<int>& a) {
    int n = a.size();                                // Размер массива
    for (int i = 0; i < n - 1; i++) {                // Позиция, куда ставим минимум
        int minIdx = i;                              // Стартовый индекс минимума

#pragma omp parallel for                              // Параллельно перебираем кандидатов j
        for (int j = i + 1; j < n; j++) {            // Поиск минимального элемента справа
#pragma omp critical                                  // Защищаем доступ к minIdx (общая переменная)
            {
                if (a[j] < a[minIdx])                // Если нашли элемент меньше текущего минимума
                    minIdx = j;                      // Обновляем индекс минимума
            }
        }

        swap(a[i], a[minIdx]);                       // Ставим найденный минимум на позицию i
    }
}

/*
  insertionSortPar(a)
  - Вставки зависят от результатов предыдущих шагов,
    потому что "левая часть" должна быть уже отсортирована.
  - Если распараллелить внешний цикл i, потоки начнут менять один и тот же массив
    и ломать порядок (гонки данных + нарушение алгоритма).
*/
void insertionSortPar(vector<int>& a) {
    int n = a.size();                                // Размер массива
#pragma omp parallel for                              // Пытаемся распараллелить внешний цикл (проблемно для вставок)
    for (int i = 1; i < n; i++) {                    // Каждый поток берёт своё i
        int key = a[i];                              // Значение, которое нужно вставить
        int j = i - 1;                               // Двигаемся влево
        while (j >= 0 && a[j] > key) {               // Пока слева элементы больше key
            a[j + 1] = a[j];                         // Сдвигаем вправо
            j--;
        }
        a[j + 1] = key;                              // Вставляем key
    }
}

/*
  measureTime(sortFunc, a)
  - Измеряет время работы функции сортировки sortFunc на копии массива a.
*/
double measureTime(void (*sortFunc)(vector<int>&), vector<int> a) {
    auto start = high_resolution_clock::now();       // Фиксируем время до запуска сортировки
    sortFunc(a);                                     // Запускаем сортировку (она меняет копию массива a)
    auto end = high_resolution_clock::now();         // Фиксируем время после сортировки
    return duration<double, milli>(end - start).count(); // Возвращаем длительность в миллисекундах
}

int main() {
    vector<int> sizes = { 1000, 10000, 100000 };     // Набор размеров массивов для сравнения скорости

    for (int n : sizes) {                            // Перебираем каждый размер массива
        cout << "\nArray size: " << n << endl;       // Печатаем текущий размер теста

        vector<int> a = generateArray(n);            // Генерируем исходный массив (один раз для всех сортировок)

        // Измеряем время пузырьковой сортировки (последовательно и параллельно)
        cout << "Bubble sort seq:      " << measureTime(bubbleSortSeq, a) << " ms\n";
        cout << "Bubble sort parallel: " << measureTime(bubbleSortPar, a) << " ms\n";

        // Измеряем время сортировки выбором (последовательно и параллельно)
        cout << "Selection sort seq:   " << measureTime(selectionSortSeq, a) << " ms\n";
        cout << "Selection sort par:   " << measureTime(selectionSortPar, a) << " ms\n";

        // Измеряем время сортировки вставками (последовательно и параллельно)
        cout << "Insertion sort seq:   " << measureTime(insertionSortSeq, a) << " ms\n";
        cout << "Insertion sort par:   " << measureTime(insertionSortPar, a) << " ms\n";
    }

    return 0;                                        // Завершаем программу успешно
}
